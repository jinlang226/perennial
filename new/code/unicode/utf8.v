(* autogenerated from unicode/utf8 *)

From New.golang Require Import defn.
Require Export New.trusted_code.unicode.utf8.
Import utf8.
Definition utf8 : go_string := "unicode/utf8".

Module utf8.

Module acceptRange. Definition id : go_string := "unicode/utf8.acceptRange"%go. End acceptRange.

Section code.
Context `{ffi_syntax}.


Axiom RuneError : Z.

Axiom RuneSelf : Z.

Axiom MaxRune : Z.

Axiom UTFMax : Z.

Axiom surrogateMin : Z.

Axiom surrogateMax : Z.

Axiom t1 : Z.

Axiom tx : Z.

Axiom t2 : Z.

Axiom t3 : Z.

Axiom t4 : Z.

Axiom t5 : Z.

Axiom maskx : Z.

Axiom mask2 : Z.

Axiom mask3 : Z.

Axiom mask4 : Z.

Axiom rune1Max : Z.

Axiom rune2Max : Z.

Axiom rune3Max : Z.

Axiom locb : Z.

Axiom hicb : Z.

Axiom xx : Z.

Axiom as' : Z.

Axiom s1 : Z.

Axiom s2 : Z.

Axiom s3 : Z.

Axiom s4 : Z.

Axiom s5 : Z.

Axiom s6 : Z.

Axiom s7 : Z.

Axiom runeErrorByte0 : Z.

Axiom runeErrorByte1 : Z.

Axiom runeErrorByte2 : Z.

Definition first : go_string := "unicode/utf8.first"%go.

Axiom first'init : val.

Axiom acceptRange : go_type.

Definition acceptRanges : go_string := "unicode/utf8.acceptRanges"%go.

Axiom acceptRanges'init : val.

Definition FullRune : go_string := "unicode/utf8.FullRune"%go.

Definition FullRuneInString : go_string := "unicode/utf8.FullRuneInString"%go.

Definition DecodeRune : go_string := "unicode/utf8.DecodeRune"%go.

(* DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
   its width in bytes. If p is empty it returns ([RuneError], 0). Otherwise, if
   the encoding is invalid, it returns (RuneError, 1). Both are impossible
   results for correct, non-empty UTF-8.

   An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
   out of range, or is not the shortest possible UTF-8 encoding for the
   value. No other validation is performed.

   go: utf8.go:157:6 *)
Definition DecodeRuneⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "size" := (mem.alloc (type.zero_val #intT)) in
    let: "r" := (mem.alloc (type.zero_val #runeT)) in
    let: "p" := (mem.alloc "p") in
    let: "n" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "p") in
    slice.len "$a0") in
    do:  ("n" <-[#intT] "$r0");;;
    (if: int_lt (![#intT] "n") #(W64 1)
    then return: (#(W32 RuneError), #(W64 0))
    else do:  #());;;
    let: "p0" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "p") #(W64 0))) in
    do:  ("p0" <-[#byteT] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #uint8T)) in
    let: "$r0" := (![#uint8T] (array.elem_ref #uint8T (![type.arrayT #(W64 256) #uint8T] (globals.get #first)) (![#byteT] "p0"))) in
    do:  ("x" <-[#uint8T] "$r0");;;
    (if: (![#uint8T] "x") ≥ #(W8 as')
    then
      let: "mask" := (mem.alloc (type.zero_val #runeT)) in
      let: "$r0" := (((u_to_w32 (![#uint8T] "x")) ≪ #(W32 31)) ≫ #(W32 31)) in
      do:  ("mask" <-[#runeT] "$r0");;;
      return: (((u_to_w32 (![#byteT] (slice.elem_ref #byteT (![#sliceT] "p") #(W64 0)))) `and_not` (![#runeT] "mask")) `or` (#(W32 RuneError) `and` (![#runeT] "mask")), #(W64 1))
    else do:  #());;;
    let: "sz" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (u_to_w64 ((![#uint8T] "x") `and` #(W8 7))) in
    do:  ("sz" <-[#intT] "$r0");;;
    let: "accept" := (mem.alloc (type.zero_val #acceptRange)) in
    let: "$r0" := (![#acceptRange] (array.elem_ref #acceptRange (![type.arrayT #(W64 16) #acceptRange] (globals.get #acceptRanges)) ((![#uint8T] "x") ≫ #(W8 4)))) in
    do:  ("accept" <-[#acceptRange] "$r0");;;
    (if: int_lt (![#intT] "n") (![#intT] "sz")
    then return: (#(W32 RuneError), #(W64 1))
    else do:  #());;;
    let: "b1" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "p") #(W64 1))) in
    do:  ("b1" <-[#byteT] "$r0");;;
    (if: ((![#byteT] "b1") < (![#uint8T] (struct.field_ref #acceptRange #"lo"%go "accept"))) || ((![#uint8T] (struct.field_ref #acceptRange #"hi"%go "accept")) < (![#byteT] "b1"))
    then return: (#(W32 RuneError), #(W64 1))
    else do:  #());;;
    (if: int_leq (![#intT] "sz") #(W64 2)
    then return: (((u_to_w32 ((![#byteT] "p0") `and` #(W8 mask2))) ≪ #(W32 6)) `or` (u_to_w32 ((![#byteT] "b1") `and` #(W8 maskx))), #(W64 2))
    else do:  #());;;
    let: "b2" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "p") #(W64 2))) in
    do:  ("b2" <-[#byteT] "$r0");;;
    (if: ((![#byteT] "b2") < #(W8 locb)) || (#(W8 hicb) < (![#byteT] "b2"))
    then return: (#(W32 RuneError), #(W64 1))
    else do:  #());;;
    (if: int_leq (![#intT] "sz") #(W64 3)
    then return: ((((u_to_w32 ((![#byteT] "p0") `and` #(W8 mask3))) ≪ #(W32 12)) `or` ((u_to_w32 ((![#byteT] "b1") `and` #(W8 maskx))) ≪ #(W32 6))) `or` (u_to_w32 ((![#byteT] "b2") `and` #(W8 maskx))), #(W64 3))
    else do:  #());;;
    let: "b3" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "p") #(W64 3))) in
    do:  ("b3" <-[#byteT] "$r0");;;
    (if: ((![#byteT] "b3") < #(W8 locb)) || (#(W8 hicb) < (![#byteT] "b3"))
    then return: (#(W32 RuneError), #(W64 1))
    else do:  #());;;
    return: (((((u_to_w32 ((![#byteT] "p0") `and` #(W8 mask4))) ≪ #(W32 18)) `or` ((u_to_w32 ((![#byteT] "b1") `and` #(W8 maskx))) ≪ #(W32 12))) `or` ((u_to_w32 ((![#byteT] "b2") `and` #(W8 maskx))) ≪ #(W32 6))) `or` (u_to_w32 ((![#byteT] "b3") `and` #(W8 maskx))), #(W64 4))).

Definition DecodeRuneInString : go_string := "unicode/utf8.DecodeRuneInString"%go.

Definition DecodeLastRune : go_string := "unicode/utf8.DecodeLastRune"%go.

Definition DecodeLastRuneInString : go_string := "unicode/utf8.DecodeLastRuneInString"%go.

Definition RuneLen : go_string := "unicode/utf8.RuneLen"%go.

Definition EncodeRune : go_string := "unicode/utf8.EncodeRune"%go.

Definition encodeRuneNonASCII : go_string := "unicode/utf8.encodeRuneNonASCII"%go.

Definition AppendRune : go_string := "unicode/utf8.AppendRune"%go.

Definition appendRuneNonASCII : go_string := "unicode/utf8.appendRuneNonASCII"%go.

Definition RuneCount : go_string := "unicode/utf8.RuneCount"%go.

Definition RuneCountInString : go_string := "unicode/utf8.RuneCountInString"%go.

Definition RuneStart : go_string := "unicode/utf8.RuneStart"%go.

(* RuneStart reports whether the byte could be the first byte of an encoded,
   possibly invalid rune. Second and subsequent bytes always have the top two
   bits set to 10.

   go: utf8.go:437:6 *)
Definition RuneStartⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    return: (((![#byteT] "b") `and` #(W8 192)) ≠ #(W8 128))).

Definition Valid : go_string := "unicode/utf8.Valid"%go.

Definition ValidString : go_string := "unicode/utf8.ValidString"%go.

Definition ValidRune : go_string := "unicode/utf8.ValidRune"%go.

(* ValidRune reports whether r can be legally encoded as UTF-8.
   Code points that are out of range or a surrogate half are illegal.

   go: utf8.go:538:6 *)
Definition ValidRuneⁱᵐᵖˡ : val :=
  λ: "r",
    exception_do (let: "r" := (mem.alloc "r") in
    let: "$sw" := #true in
    (if: "$sw" = ((int_leq #(W32 0) (![#runeT] "r")) && (int_lt (![#runeT] "r") #(W32 surrogateMin)))
    then return: (#true)
    else
      (if: "$sw" = ((int_lt #(W32 surrogateMax) (![#runeT] "r")) && (int_leq (![#runeT] "r") #(W32 MaxRune)))
      then return: (#true)
      else do:  #()));;;
    return: (#false)).

Definition vars' : list (go_string * go_type) := [].

Axiom encodeRuneNonASCIIⁱᵐᵖˡ : val.

Axiom AppendRuneⁱᵐᵖˡ : val.

Axiom appendRuneNonASCIIⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(FullRune, FullRuneⁱᵐᵖˡ); (FullRuneInString, FullRuneInStringⁱᵐᵖˡ); (DecodeRune, DecodeRuneⁱᵐᵖˡ); (DecodeRuneInString, DecodeRuneInStringⁱᵐᵖˡ); (DecodeLastRune, DecodeLastRuneⁱᵐᵖˡ); (DecodeLastRuneInString, DecodeLastRuneInStringⁱᵐᵖˡ); (RuneLen, RuneLenⁱᵐᵖˡ); (EncodeRune, EncodeRuneⁱᵐᵖˡ); (encodeRuneNonASCII, encodeRuneNonASCIIⁱᵐᵖˡ); (AppendRune, AppendRuneⁱᵐᵖˡ); (appendRuneNonASCII, appendRuneNonASCIIⁱᵐᵖˡ); (RuneCount, RuneCountⁱᵐᵖˡ); (RuneCountInString, RuneCountInStringⁱᵐᵖˡ); (RuneStart, RuneStartⁱᵐᵖˡ); (Valid, Validⁱᵐᵖˡ); (ValidString, ValidStringⁱᵐᵖˡ); (ValidRune, ValidRuneⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(acceptRange.id, []); (ptrT.id acceptRange.id, [])].

#[global] Instance info' : PkgInfo utf8.utf8 :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #utf8.utf8 (λ: <>,
      exception_do (do:  (package.alloc utf8.utf8 #());;;
      do:  (first'init #());;;
      do:  (acceptRanges'init #()))
      ).

End code.
End utf8.
